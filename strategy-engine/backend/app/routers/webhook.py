"""
Strategy Engine — Production System Webhook Receiver

Implements POST /api/webhook/production-callback

This is THE endpoint where the Production System (vdo-content) notifies
the Strategy Engine that content generation is COMPLETE or FAILED.

On SUCCESS:
  1. Validate HMAC-SHA256 signature (X-Signature-256 header)
  2. Look up campaign by correlation_id
  3. Update StrategyCampaign.status → COMPLETED
  4. Update each ContentNode with production_url + published_at
  5. Ingest published URLs into Qdrant (for future SEO interlinking)

On FAILURE:
  1. Validate signature
  2. Look up campaign by correlation_id
  3. Update status → PRODUCTION_FAILED with error details

Idempotency: if we receive the same callback twice (e.g., Production retried),
we return 200 OK but skip the DB writes (campaign already COMPLETED).
"""

from __future__ import annotations

import logging
from datetime import datetime, timezone
from typing import Optional

from fastapi import APIRouter, Depends, Header, HTTPException, Request, status
from pydantic import BaseModel, Field
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.config import get_settings
from app.db.base import get_db
from app.db.models import ContentNode, StrategyCampaign
from app.services.correlation import verify_webhook_signature

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api/webhook", tags=["webhook"])


# ============================================================
# Pydantic Models — Production System Callback Payload
# ============================================================


class ProductionNodeResult(BaseModel):
    """Status of one ContentNode after production processing."""

    slug: str = Field(description="URL slug that matches ContentNode.slug")
    url: str = Field(description="Final published URL on the production site")
    status: str = Field(default="live", description="live | failed | processing")
    published_at: Optional[datetime] = Field(default=None)


class ProductionCallbackPayload(BaseModel):
    """
    Webhook payload from the Production System.

    The Production System MUST include correlation_id in every callback —
    this is the only cross-system identifier the Strategy Engine uses.
    """

    correlation_id: str = Field(
        description="The SE-{tenant}-{blueprint}-{ts} ID generated by Strategy Engine"
    )
    production_job_id: str = Field(description="Production System's internal job ID")
    status: str = Field(description="success | failed | partial")
    nodes: list[ProductionNodeResult] = Field(
        default_factory=list,
        description="Per-node results with final published URLs",
    )
    error_code: Optional[str] = Field(default=None)
    error_message: Optional[str] = Field(default=None)
    processed_at: Optional[datetime] = Field(default=None)


class CallbackAck(BaseModel):
    """Response returned to the Production System after processing its callback."""

    received: bool = True
    correlation_id: str
    nodes_updated: int
    campaign_status: str


# ============================================================
# Webhook Endpoint
# ============================================================


@router.post(
    "/production-callback",
    response_model=CallbackAck,
    summary="Receive production completion callback from vdo-content",
    description=(
        "Called by the Production System when content generation is complete or failed. "
        "Validates HMAC-SHA256 signature, updates campaign status, and ingests "
        "published URLs into the Qdrant vector DB for future interlinking."
    ),
)
async def production_callback(
    request: Request,
    payload: ProductionCallbackPayload,
    db: AsyncSession = Depends(get_db),
    x_signature_256: Optional[str] = Header(default=None, alias="X-Signature-256"),
) -> CallbackAck:
    """
    Production System Webhook receiver.

    Security: validates HMAC-SHA256 signature before processing.
    Idempotency: if campaign is already COMPLETED, returns 200 without re-processing.
    """
    settings = get_settings()

    # ── Security: validate HMAC signature ────────────────────────────────
    if settings.production_webhook_token:
        if not x_signature_256:
            logger.warning(
                f"[Webhook] Missing X-Signature-256 for correlation_id={payload.correlation_id}"
            )
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Missing webhook signature",
            )
        raw_body = await request.body()
        if not verify_webhook_signature(
            raw_body=raw_body,
            secret=settings.production_webhook_token,
            received_sig=x_signature_256,
        ):
            logger.error(
                f"[Webhook] Invalid signature for correlation_id={payload.correlation_id}"
            )
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid webhook signature",
            )
    # ─────────────────────────────────────────────────────────────────────

    logger.info(
        f"[Webhook] Received {payload.status!r} callback "
        f"for correlation_id={payload.correlation_id}, "
        f"nodes={len(payload.nodes)}"
    )

    # ── Look up campaign by correlation_id ───────────────────────────────
    result = await db.execute(
        select(StrategyCampaign).where(
            StrategyCampaign.correlation_id == payload.correlation_id
        )
    )
    campaign = result.scalar_one_or_none()

    if not campaign:
        logger.error(f"[Webhook] No campaign found for correlation_id={payload.correlation_id}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"No campaign found for correlation_id={payload.correlation_id}",
        )

    # ── Idempotency: skip re-processing if already terminal ──────────────
    if campaign.status == "COMPLETED":
        logger.info(
            f"[Webhook] Campaign {campaign.id} already COMPLETED — "
            "returning 200 without re-processing (idempotent)"
        )
        return CallbackAck(
            correlation_id=payload.correlation_id,
            nodes_updated=0,
            campaign_status="COMPLETED",
        )
    # ─────────────────────────────────────────────────────────────────────

    nodes_updated = 0

    if payload.status == "success":
        # ── Update each ContentNode with production URL ───────────────────
        for node_result in payload.nodes:
            node_query = await db.execute(
                select(ContentNode).where(
                    ContentNode.campaign_id == campaign.id,
                    ContentNode.slug == node_result.slug,
                )
            )
            node = node_query.scalar_one_or_none()
            if node:
                node.production_url = node_result.url
                node.production_status = node_result.status
                node.published_at = node_result.published_at or datetime.now(timezone.utc)
                db.add(node)
                nodes_updated += 1
            else:
                logger.warning(
                    f"[Webhook] No ContentNode found for slug={node_result.slug!r} "
                    f"in campaign={campaign.id}"
                )

        # ── Update campaign status ────────────────────────────────────────
        campaign.status = "COMPLETED"
        campaign.completed_at = datetime.now(timezone.utc)
        db.add(campaign)

        logger.info(
            f"[Webhook] ✅ Campaign {campaign.id} COMPLETED — "
            f"{nodes_updated}/{len(payload.nodes)} nodes updated"
        )

        # ── Ingest published URLs into Qdrant for future interlinking ─────
        await _ingest_published_urls_to_qdrant(campaign_id=campaign.id, nodes=payload.nodes)

    else:
        # FAILURE callback
        campaign.status = "PRODUCTION_FAILED"
        campaign.dispatch_error = (
            f"[{payload.error_code}] {payload.error_message}"
            if payload.error_code
            else payload.error_message or "Unknown production error"
        )
        db.add(campaign)

        logger.warning(
            f"[Webhook] ❌ Campaign {campaign.id} PRODUCTION_FAILED — "
            f"error={campaign.dispatch_error}"
        )

    return CallbackAck(
        correlation_id=payload.correlation_id,
        nodes_updated=nodes_updated,
        campaign_status=campaign.status,
    )


# ============================================================
# Helper: Ingest Published URLs into Qdrant
# ============================================================


async def _ingest_published_urls_to_qdrant(
    campaign_id: str,
    nodes: list[ProductionNodeResult],
) -> None:
    """
    Ingest published content URLs into the Qdrant vector DB after SUCCESS.

    This closes the feedback loop: future Agent 3 RAG queries will find
    these newly published pages for interlinking and cannibalization checks.
    Runs fire-and-forget; failure does not affect the 200 ACK to Production.
    """
    try:
        from app.services.rag_service import get_rag_service

        rag = get_rag_service()
        ingested = 0
        for node in nodes:
            if node.url and node.status == "live":
                await rag.ingest_content(
                    url=node.url,
                    title=node.slug.replace("-", " ").title(),
                    primary_keyword=node.slug,  # Best available at this point
                    content_type="published",
                    metadata={"source": "production_webhook", "campaign_id": campaign_id},
                )
                ingested += 1
        logger.info(
            f"[Webhook] Qdrant: ingested {ingested}/{len(nodes)} published URLs "
            f"for campaign={campaign_id}"
        )
    except Exception as e:
        # Non-fatal — log but don't fail the webhook response
        logger.warning(f"[Webhook] Qdrant ingestion failed (non-fatal): {e}")
